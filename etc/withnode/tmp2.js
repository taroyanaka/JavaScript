({
	"plugins": ["jsdom-quokka-plugin"],
})

const R = require(`ramda`);

const moment = require(`moment`);
moment()
// moment("2018-02-04T14:12:57.506")
moment().year()
// 2018
moment().month()
// 1 ← 1月が0なので注意
moment().date()
// 4 ← dayだと曜日番号になるので注意
moment().day()
// 0 ← 日曜日が0
moment().hour()
moment().minutes()
moment().second()

let nowMoment = moment().toDate();
// new Date();
console.log(nowMoment);
console.log(nowMoment.toString());
console.log(moment());
console.log(new Date());

// const format = require('date-fns/format');
// console.log(
//   format(new Date(2017, 6), 'mm/dd')
// );



const all = [
	[
		"__"
	],
	[
		"add",
		"subtract"
	],
	[
		"addIndex"
	],
	[
		"adjust",
		"update"
	],
	[
		"all",
		"any",
		"none",
		"transduce"
	],
	[
		"allPass",
		"anyPass"
	],
	[
		"always"
	],
	[
		"and",
		"both",
		"xor"
	],
	[
		"andThen",
		"otherwise"
	],
	[
		"any",
		"all",
		"none",
		"transduce"
	],
	[
		"anyPass",
		"allPass"
	],
	[
		"ap"
	],
	[
		"aperture",
		"transduce"
	],
	[
		"append",
		"prepend"
	],
	[
		"apply",
		"call",
		"unapply"
	],
	[
		"applySpec",
		"converge",
		"juxt"
	],
	[
		"applyTo"
	],
	[
		"ascend",
		"descend"
	],
	[
		"assoc",
		"dissoc",
		"pick"
	],
	[
		"assocPath",
		"dissocPath"
	],
	[
		"binary",
		"nAry",
		"unary"
	],
	[
		"bind",
		"partial"
	],
	[
		"both",
		"and"
	],
	[
		"call",
		"apply"
	],
	[
		"chain"
	],
	[
		"clamp"
	],
	[
		"clone"
	],
	[
		"comparator"
	],
	[
		"complement",
		"not"
	],
	[
		"compose",
		"pipe"
	],
	[
		"composeK",
		"pipeK"
	],
	[
		"composeP",
		"pipeP"
	],
	[
		"composeWith",
		"compose",
		"pipeWith"
	],
	[
		"concat"
	],
	[
		"cond",
		"ifElse",
		"unless",
		"when"
	],
	[
		"construct",
		"invoker"
	],
	[
		"constructN"
	],
	[
		"contains",
		"includes"
	],
	[
		"converge",
		"useWith"
	],
	[
		"countBy"
	],
	[
		"curry",
		"curryN",
		"partial"
	],
	[
		"curryN",
		"curry"
	],
	[
		"dec",
		"inc"
	],
	[
		"defaultTo"
	],
	[
		"descend",
		"ascend"
	],
	[
		"difference",
		"differenceWith",
		"symmetricDifference",
		"symmetricDifferenceWith",
		"without"
	],
	[
		"differenceWith",
		"difference",
		"symmetricDifference",
		"symmetricDifferenceWith"
	],
	[
		"dissoc",
		"assoc",
		"omit"
	],
	[
		"dissocPath",
		"assocPath"
	],
	[
		"divide",
		"multiply"
	],
	[
		"drop",
		"take",
		"transduce",
		"dropLast",
		"dropWhile"
	],
	[
		"dropLast",
		"takeLast",
		"drop",
		"dropWhile",
		"dropLastWhile"
	],
	[
		"dropLastWhile",
		"takeLastWhile",
		"addIndex",
		"drop",
		"dropWhile"
	],
	[
		"dropRepeats",
		"transduce"
	],
	[
		"dropRepeatsWith",
		"transduce"
	],
	[
		"dropWhile",
		"takeWhile",
		"transduce",
		"addIndex"
	],
	[
		"either",
		"or"
	],
	[
		"empty"
	],
	[
		"endsWith",
		"startsWith"
	],
	[
		"eqBy"
	],
	[
		"eqProps"
	],
	[
		"equals"
	],
	[
		"evolve"
	],
	[
		"F",
		"T"
	],
	[
		"filter",
		"reject",
		"transduce",
		"addIndex"
	],
	[
		"find",
		"transduce"
	],
	[
		"findIndex",
		"transduce"
	],
	[
		"findLast",
		"transduce"
	],
	[
		"findLastIndex",
		"transduce"
	],
	[
		"flatten",
		"unnest"
	],
	[
		"flip"
	],
	[
		"forEach",
		"addIndex"
	],
	[
		"forEachObjIndexed"
	],
	[
		"fromPairs",
		"toPairs",
		"pair"
	],
	[
		"groupBy",
		"reduceBy",
		"transduce"
	],
	[
		"groupWith"
	],
	[
		"gt",
		"lt"
	],
	[
		"gte",
		"lte"
	],
	[
		"has"
	],
	[
		"hasIn"
	],
	[
		"hasPath",
		"has"
	],
	[
		"head",
		"tail",
		"init",
		"last"
	],
	[
		"identical"
	],
	[
		"identity"
	],
	[
		"ifElse",
		"unless",
		"when",
		"cond"
	],
	[
		"inc",
		"dec"
	],
	[
		"includes",
		"any"
	],
	[
		"indexBy"
	],
	[
		"indexOf",
		"lastIndexOf"
	],
	[
		"init",
		"last",
		"head",
		"tail"
	],
	[
		"innerJoin",
		"intersection"
	],
	[
		"insert"
	],
	[
		"insertAll"
	],
	[
		"intersection",
		"innerJoin"
	],
	[
		"intersperse"
	],
	[
		"into",
		"transduce"
	],
	[
		"invert",
		"invertObj"
	],
	[
		"invertObj",
		"invert"
	],
	[
		"invoker",
		"construct"
	],
	[
		"is"
	],
	[
		"isEmpty",
		"empty"
	],
	[
		"isNil"
	],
	[
		"join",
		"split"
	],
	[
		"juxt",
		"applySpec"
	],
	[
		"keys",
		"keysIn",
		"values"
	],
	[
		"keysIn",
		"keys",
		"valuesIn"
	],
	[
		"last",
		"init",
		"head",
		"tail"
	],
	[
		"lastIndexOf",
		"indexOf"
	],
	[
		"length"
	],
	[
		"lens",
		"view",
		"set",
		"over",
		"lensIndex",
		"lensProp"
	],
	[
		"lensIndex",
		"view",
		"set",
		"over",
		"nth"
	],
	[
		"lensPath",
		"view",
		"set",
		"over"
	],
	[
		"lensProp",
		"view",
		"set",
		"over"
	],
	[
		"lift",
		"liftN"
	],
	[
		"liftN",
		"lift",
		"ap"
	],
	[
		"lt",
		"gt"
	],
	[
		"lte",
		"gte"
	],
	[
		"map",
		"transduce",
		"addIndex"
	],
	[
		"mapAccum",
		"scan",
		"addIndex",
		"mapAccumRight"
	],
	[
		"mapAccumRight",
		"addIndex",
		"mapAccum"
	],
	[
		"mapObjIndexed",
		"map"
	],
	[
		"match",
		"test"
	],
	[
		"mathMod",
		"modulo"
	],
	[
		"max",
		"maxBy",
		"min"
	],
	[
		"maxBy",
		"max",
		"minBy"
	],
	[
		"mean",
		"median"
	],
	[
		"median",
		"mean"
	],
	[
		"memoizeWith"
	],
	[
		"merge",
		"mergeRight",
		"mergeDeepRight",
		"mergeWith",
		"mergeWithKey"
	],
	[
		"mergeAll",
		"reduce"
	],
	[
		"mergeDeepLeft",
		"merge",
		"mergeDeepRight",
		"mergeDeepWith",
		"mergeDeepWithKey"
	],
	[
		"mergeDeepRight",
		"merge",
		"mergeDeepLeft",
		"mergeDeepWith",
		"mergeDeepWithKey"
	],
	[
		"mergeDeepWith",
		"mergeWith",
		"mergeDeepWithKey"
	],
	[
		"mergeDeepWithKey",
		"mergeWithKey",
		"mergeDeepWith"
	],
	[
		"mergeLeft",
		"mergeRight",
		"mergeDeepLeft",
		"mergeWith",
		"mergeWithKey"
	],
	[
		"mergeRight",
		"mergeLeft",
		"mergeDeepRight",
		"mergeWith",
		"mergeWithKey"
	],
	[
		"mergeWith",
		"mergeDeepWith",
		"merge",
		"mergeWithKey"
	],
	[
		"mergeWithKey",
		"mergeDeepWithKey",
		"merge",
		"mergeWith"
	],
	[
		"min",
		"minBy",
		"max"
	],
	[
		"minBy",
		"min",
		"maxBy"
	],
	[
		"modulo",
		"mathMod"
	],
	[
		"move"
	],
	[
		"multiply",
		"divide"
	],
	[
		"nAry",
		"binary",
		"unary"
	],
	[
		"negate"
	],
	[
		"none",
		"all",
		"any"
	],
	[
		"not",
		"complement"
	],
	[
		"nth"
	],
	[
		"nthArg"
	],
	[
		"o",
		"compose",
		"pipe"
	],
	[
		"objOf",
		"pair"
	],
	[
		"of"
	],
	[
		"omit",
		"pick"
	],
	[
		"once"
	],
	[
		"or",
		"either",
		"xor"
	],
	[
		"otherwise",
		"then"
	],
	[
		"over",
		"prop",
		"lensIndex",
		"lensProp"
	],
	[
		"pair",
		"objOf",
		"of"
	],
	[
		"partial",
		"partialRight",
		"curry"
	],
	[
		"partialRight",
		"partial"
	],
	[
		"partition",
		"filter",
		"reject"
	],
	[
		"path",
		"prop",
		"nth"
	],
	[
		"pathEq"
	],
	[
		"pathOr"
	],
	[
		"paths",
		"path"
	],
	[
		"pathSatisfies",
		"propSatisfies",
		"path"
	],
	[
		"pick",
		"omit",
		"props"
	],
	[
		"pickAll",
		"pick"
	],
	[
		"pickBy",
		"pick",
		"filter"
	],
	[
		"pipe",
		"compose"
	],
	[
		"pipeK",
		"composeK"
	],
	[
		"pipeP",
		"composeP"
	],
	[
		"pipeWith",
		"composeWith",
		"pipe"
	],
	[
		"pluck",
		"props"
	],
	[
		"prepend",
		"append"
	],
	[
		"product",
		"reduce"
	],
	[
		"project"
	],
	[
		"prop",
		"path",
		"nth"
	],
	[
		"propEq",
		"whereEq",
		"propSatisfies",
		"equals"
	],
	[
		"propIs",
		"is",
		"propSatisfies"
	],
	[
		"propOr"
	],
	[
		"props"
	],
	[
		"propSatisfies",
		"where",
		"propEq",
		"propIs"
	],
	[
		"range"
	],
	[
		"reduce",
		"reduced",
		"addIndex",
		"reduceRight"
	],
	[
		"reduceBy",
		"groupBy",
		"reduce"
	],
	[
		"reduced",
		"reduce",
		"reduceWhile",
		"transduce"
	],
	[
		"reduceRight",
		"reduce",
		"addIndex"
	],
	[
		"reduceWhile",
		"reduce",
		"reduced"
	],
	[
		"reject",
		"filter",
		"transduce",
		"addIndex"
	],
	[
		"remove",
		"without"
	],
	[
		"repeat",
		"times"
	],
	[
		"replace"
	],
	[
		"reverse"
	],
	[
		"scan",
		"reduce",
		"mapAccum"
	],
	[
		"sequence",
		"traverse"
	],
	[
		"set",
		"prop",
		"lensIndex",
		"lensProp"
	],
	[
		"slice"
	],
	[
		"sort"
	],
	[
		"sortBy"
	],
	[
		"sortWith"
	],
	[
		"split",
		"join"
	],
	[
		"splitAt"
	],
	[
		"splitEvery"
	],
	[
		"splitWhen"
	],
	[
		"startsWith",
		"endsWith"
	],
	[
		"subtract",
		"add"
	],
	[
		"sum",
		"reduce"
	],
	[
		"symmetricDifference",
		"symmetricDifferenceWith",
		"difference",
		"differenceWith"
	],
	[
		"symmetricDifferenceWith",
		"symmetricDifference",
		"difference",
		"differenceWith"
	],
	[
		"T",
		"F"
	],
	[
		"tail",
		"head",
		"init",
		"last"
	],
	[
		"take",
		"drop"
	],
	[
		"takeLast",
		"dropLast"
	],
	[
		"takeLastWhile",
		"dropLastWhile",
		"addIndex"
	],
	[
		"takeWhile",
		"dropWhile",
		"transduce",
		"addIndex"
	],
	[
		"tap"
	],
	[
		"test",
		"match"
	],
	[
		"thunkify",
		"partial",
		"partialRight"
	],
	[
		"times",
		"repeat"
	],
	[
		"toLower",
		"toUpper"
	],
	[
		"toPairs",
		"fromPairs"
	],
	[
		"toPairsIn"
	],
	[
		"toString"
	],
	[
		"toUpper",
		"toLower"
	],
	[
		"transduce",
		"reduce",
		"reduced",
		"into"
	],
	[
		"transpose"
	],
	[
		"traverse",
		"sequence"
	],
	[
		"trim"
	],
	[
		"tryCatch"
	],
	[
		"type"
	],
	[
		"unapply",
		"apply"
	],
	[
		"unary",
		"binary",
		"nAry"
	],
	[
		"uncurryN",
		"curry"
	],
	[
		"unfold"
	],
	[
		"union"
	],
	[
		"unionWith",
		"union"
	],
	[
		"uniq"
	],
	[
		"uniqBy"
	],
	[
		"uniqWith"
	],
	[
		"unless",
		"ifElse",
		"when",
		"cond"
	],
	[
		"unnest",
		"flatten",
		"chain"
	],
	[
		"until"
	],
	[
		"update",
		"adjust"
	],
	[
		"useWith",
		"converge"
	],
	[
		"values",
		"valuesIn",
		"keys"
	],
	[
		"valuesIn",
		"values",
		"keysIn"
	],
	[
		"view",
		"prop",
		"lensIndex",
		"lensProp"
	],
	[
		"when",
		"ifElse",
		"unless",
		"cond"
	],
	[
		"where",
		"propSatisfies",
		"whereEq"
	],
	[
		"whereEq",
		"propEq",
		"where"
	],
	[
		"without",
		"transduce",
		"difference",
		"remove"
	],
	[
		"xor",
		"or",
		"and"
	],
	[
		"xprod"
	],
	[
		"zip"
	],
	[
		"zipObj"
	],
	[
		"zipWith"
	]
]



let template0 =
	`const data = {
  nodes: [
    {
      id: "node1",
      label: "node1",
    },
    {
      id: "node2",
      label: "node2",
    },
    {
      id: "node3",
      label: "node3",
    },
  ],
  edges: [
    {
      source: "node1",
      target: "node2",
    },
    {
      source: "node1",
      target: "node3",
    },
  ]
};`

const data =
	`{
  nodes: [
    {
      id: "all",
      label: "all",
    },
    {
      id: "any",
      label: "any",
    },
    {
      id: "none",
      label: "none",
    },
	{
      id: "transduce",
      label: "transduce",
    },
  ],
  edges: [
    {
      source: "all",
      target: "any",
    },
    {
      source: "all",
      target: "none",
    },
    {
      source: "all",
      target: "transduce",
    },
  ]
};`



const ar0 = [
	"all",
	"any",
	"none",
	"transduce"
]
const makeData0 = (AR) => {
	const template0 = `{
	nodes: [`
	const node0 =
		`{
      id: "${AR[0]}",
      label: "${AR[0]}",
    },`
	const withoutArZeroElm = R.remove(0, 1, AR);
	const makeNode = (ELM) => {
		return ELM.map(V => {
			return `{id: "${V}",label: "${V}"},`
		}).join("")
	};
	const nodes = makeNode(withoutArZeroElm);
	const template1 =
		`],
	edges: [`
	const makeEdge = (ELM) => {
		return ELM.map(V => {
			return `{source: "${V}",target: "${AR[0]}"},`
		}).join("")
	};
	const edges = makeEdge(withoutArZeroElm);
	const template2 =
		`]
	};`
	return template0 + node0 + nodes + template1 + edges + template2
};


const ar2 = [
	"all",
	"any",
	"none",
	"transduce"
]
const makeData2 = (AR) => {

};

const id = R.repeat('id', ar0.length); //=> ['hi', 'hi', 'hi', 'hi', 'hi']
const idar2pair = R.transpose([id, ar2])

// R.transpose([[10, 11], [20], [], [30, 31, 32]]) //=> [[10, 20, 30], [11, 31], [32]]


const label = R.repeat('label', ar0.length);
const labelar2pair = R.transpose([label, ar2])


const idar2pairobj = R.fromPairs([idar2pair]);

idar2pairobj