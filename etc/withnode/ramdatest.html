<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ramda test</title>
    <script src="ramda.js"></script>
</head>
<body>
    <h1></h1>
</body>
<script>
// const ar = [0,1,2];
// const ar1 = ar.slice(1,3,[10,20,30,40]);

// var slice = _curry3(_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
//   return Array.prototype.slice.call(list, fromIndex, toIndex);
// }));


// const ar1 = slice(1,3,[10,20,30,40]);
// document.querySelector("h1").textContent= ar1;
// Array.prototype.slice.call(list, fromIndex, toIndex)


// var slice = _curry3(_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
//   return Array.prototype.slice.call(list, fromIndex, toIndex);
// }));

// var drop = _curry2(_dispatchable(['drop'], _xdrop, function drop(n, xs) {
//   return slice(Math.max(0, n), Infinity, xs);
// }));

// var takeLast = _curry2(function takeLast(n, xs) {
//   return drop(n >= 0 ? xs.length - n : 0, xs);
// });

// var equals = _curry2(function equals(a, b) {
//   return _equals(a, b, [], []);
// });

// var endsWith = _curry2(function(suffix, list) {
//   return equals(takeLast(suffix.length, list), suffix);
// });

// document.querySelector("h1").textContent= Array.prototype.slice.call([0,1,2,3,4], 1, 2);
// document.querySelector("h1").textContent= Array.prototype.slice.call([0,1,2,3,4], 1, Infinity);
// document.querySelector("h1").textContent= [0,1,2,3,4].slice(1, 3);
// document.querySelector("h1").textContent= R.drop(-1,[0,1,2,3,4]);
// document.querySelector("h1").textContent= R.drop(2,[0,1,2,3]);

// document.querySelector("h1").textContent= Math.max(3,2);
// console.log(ar1);



// var contains = function contains(list, item) {
//   var idx = 0;
//   while (idx < list.length) {
//     if (list[idx] === item) {
//       return true;
//     }
//     idx += 1;
//   }
//   return false;
// };

// var take = _curry2(_dispatchable(['take'], _xtake, function take(n, xs) {
//   return slice(0, n < 0 ? Infinity : n, xs);
// }));

// var startsWith = _curry2(function(prefix, list) {
//   return equals(take(prefix.length, list), prefix);
// });

console.log(
    // R.take(1,[0,1,2])
    // R.take(-1,[0,1,2])
    R.take(0,[0,1,2])
)

// function _equals(a, b, stackA, stackB) {
//   if (identical(a, b)) {
//     return true;
//   }

//   var typeA = type(a);

//   if (typeA !== type(b)) {
//     return false;
//   }

//   if (a == null || b == null) {
//     return false;
//   }

//   if (typeof a['fantasy-land/equals'] === 'function' || typeof b['fantasy-land/equals'] === 'function') {
//     return typeof a['fantasy-land/equals'] === 'function' && a['fantasy-land/equals'](b) &&
//       typeof b['fantasy-land/equals'] === 'function' && b['fantasy-land/equals'](a);
//   }

//   if (typeof a.equals === 'function' || typeof b.equals === 'function') {
//     return typeof a.equals === 'function' && a.equals(b) &&
//       typeof b.equals === 'function' && b.equals(a);
//   }

//   switch (typeA) {
//     case 'Arguments':
//     case 'Array':
//     case 'Object':
//       if (typeof a.constructor === 'function' &&
//         _functionName(a.constructor) === 'Promise') {
//         return a === b;
//       }
//       break;
//     case 'Boolean':
//     case 'Number':
//     case 'String':
//       if (!(typeof a === typeof b && identical(a.valueOf(), b.valueOf()))) {
//         return false;
//       }
//       break;
//     case 'Date':
//       if (!identical(a.valueOf(), b.valueOf())) {
//         return false;
//       }
//       break;
//     case 'Error':
//       return a.name === b.name && a.message === b.message;
//     case 'RegExp':
//       if (!(a.source === b.source &&
//           a.global === b.global &&
//           a.ignoreCase === b.ignoreCase &&
//           a.multiline === b.multiline &&
//           a.sticky === b.sticky &&
//           a.unicode === b.unicode)) {
//         return false;
//       }
//       break;
//   }

//   var idx = stackA.length - 1;
//   while (idx >= 0) {
//     if (stackA[idx] === a) {
//       return stackB[idx] === b;
//     }
//     idx -= 1;
//   }

//   switch (typeA) {
//     case 'Map':
//       if (a.size !== b.size) {
//         return false;
//       }

//       return _uniqContentEquals(a.entries(), b.entries(), stackA.concat([a]), stackB.concat([b]));
//     case 'Set':
//       if (a.size !== b.size) {
//         return false;
//       }

//       return _uniqContentEquals(a.values(), b.values(), stackA.concat([a]), stackB.concat([b]));
//     case 'Arguments':
//     case 'Array':
//     case 'Object':
//     case 'Boolean':
//     case 'Number':
//     case 'String':
//     case 'Date':
//     case 'Error':
//     case 'RegExp':
//     case 'Int8Array':
//     case 'Uint8Array':
//     case 'Uint8ClampedArray':
//     case 'Int16Array':
//     case 'Uint16Array':
//     case 'Int32Array':
//     case 'Uint32Array':
//     case 'Float32Array':
//     case 'Float64Array':
//     case 'ArrayBuffer':
//       break;
//     default:
//       // Values of other types are only equal if identical.
//       return false;
//   }

//   var keysA = keys(a);
//   if (keysA.length !== keys(b).length) {
//     return false;
//   }

//   var extendedStackA = stackA.concat([a]);
//   var extendedStackB = stackB.concat([b]);

//   idx = keysA.length - 1;
//   while (idx >= 0) {
//     var key = keysA[idx];
//     if (!(_has(key, b) && _equals(b[key], a[key], extendedStackA, extendedStackB))) {
//       return false;
//     }
//     idx -= 1;
//   }
//   return true;
// }

function _arity(n, fn) {
  /* eslint-disable no-unused-vars */
  switch (n) {
    case 0: return function() { return fn.apply(this, arguments); };
    case 1: return function(a0) { return fn.apply(this, arguments); };
    case 2: return function(a0, a1) { return fn.apply(this, arguments); };
    case 3: return function(a0, a1, a2) { return fn.apply(this, arguments); };
    case 4: return function(a0, a1, a2, a3) { return fn.apply(this, arguments); };
    case 5: return function(a0, a1, a2, a3, a4) { return fn.apply(this, arguments); };
    case 6: return function(a0, a1, a2, a3, a4, a5) { return fn.apply(this, arguments); };
    case 7: return function(a0, a1, a2, a3, a4, a5, a6) { return fn.apply(this, arguments); };
    case 8: return function(a0, a1, a2, a3, a4, a5, a6, a7) { return fn.apply(this, arguments); };
    case 9: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) { return fn.apply(this, arguments); };
    case 10: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) { return fn.apply(this, arguments); };
    default: throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
  }
}

var _isArrayLike = _curry1(function isArrayLike(x) {
  if (_isArray(x)) { return true; }
  if (!x) { return false; }
  if (typeof x !== 'object') { return false; }
  if (_isString(x)) { return false; }
  if (x.nodeType === 1) { return !!x.length; }
  if (x.length === 0) { return true; }
  if (x.length > 0) {
    return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
  }
  return false;
});

function XWrap(fn) {
  this.f = fn;
}
XWrap.prototype['@@transducer/init'] = function() {
  throw new Error('init not implemented on XWrap');
};
XWrap.prototype['@@transducer/result'] = function(acc) { return acc; };
XWrap.prototype['@@transducer/step'] = function(acc, x) {
  return this.f(acc, x);
};
function _xwrap(fn) { return new XWrap(fn); }

var _isArray = Array.isArray || function _isArray(val) {
  return (val != null &&
          val.length >= 0 &&
          Object.prototype.toString.call(val) === '[object Array]');
};

function _arrayReduce(xf, acc, list) {
  var idx = 0;
  var len = list.length;
  while (idx < len) {
    acc = xf['@@transducer/step'](acc, list[idx]);
    if (acc && acc['@@transducer/reduced']) {
      acc = acc['@@transducer/value'];
      break;
    }
    idx += 1;
  }
  return xf['@@transducer/result'](acc);
}

function _methodReduce(xf, acc, obj, methodName) {
  return xf['@@transducer/result'](obj[methodName](bind(xf['@@transducer/step'], xf), acc));
}

function _iterableReduce(xf, acc, iter) {
  var step = iter.next();
  while (!step.done) {
    acc = xf['@@transducer/step'](acc, step.value);
    if (acc && acc['@@transducer/reduced']) {
      acc = acc['@@transducer/value'];
      break;
    }
    step = iter.next();
  }
  return xf['@@transducer/result'](acc);
}

var bind = _curry2(function bind(fn, thisObj) {
  return _arity(fn.length, function() {
    return fn.apply(thisObj, arguments);
  });
});

function _methodReduce(xf, acc, obj, methodName) {
  return xf['@@transducer/result'](obj[methodName](bind(xf['@@transducer/step'], xf), acc));
}

function _reduce(fn, acc, list) {
  if (typeof fn === 'function') {
    fn = _xwrap(fn);
  }
  if (_isArrayLike(list)) {
    return _arrayReduce(fn, acc, list);
  }
  if (typeof list['fantasy-land/reduce'] === 'function') {
    return _methodReduce(fn, acc, list, 'fantasy-land/reduce');
  }
  if (list[symIterator] != null) {
    return _iterableReduce(fn, acc, list[symIterator]());
  }
  if (typeof list.next === 'function') {
    return _iterableReduce(fn, acc, list);
  }
  if (typeof list.reduce === 'function') {
    return _methodReduce(fn, acc, list, 'reduce');
  }

  throw new TypeError('reduce: list must be array or iterable');
}

var reduce = _curry3(_reduce);

var tail = _curry1(_checkForMethod('tail', slice(1, Infinity)));

function pipe() {
  if (arguments.length === 0) {
    throw new Error('pipe requires at least one argument');
  }
  return _arity(arguments[0].length,
                reduce(_pipe, arguments[0], tail(arguments)));
}

function _isString(x) {
  return Object.prototype.toString.call(x) === '[object String]';
}

var reverse = _curry1(function reverse(list) {
  return _isString(list) ? list.split('').reverse().join('') :
                           Array.prototype.slice.call(list, 0).reverse();
});

function compose() {
  if (arguments.length === 0) {
    throw new Error('compose requires at least one argument');
  }
  return pipe.apply(this, reverse(arguments));
}

</script>
</html>